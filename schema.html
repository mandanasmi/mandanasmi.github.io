<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Role of Schemas in Reinforcement Learning</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: "Soothing Academia" - A palette using warm neutrals (bg-stone-50), with deep blues (slate) for text and accents, and a gentle teal for interactive highlights. -->
    <!-- Application Structure Plan: The SPA is designed as a narrative journey. It starts with a high-level introduction to the problem (Why?), then dives into the core methodology with interactive diagrams (How?), shows a practical application via an animated simulation (What?), compares the approach to alternatives (Context?), and concludes with future directions (What's Next?). This thematic flow is more intuitive for a general audience than the paper's academic structure. Key interactions include animated diagrams triggered by the user, a clickable comparison table, and a simulated agent plan, making abstract concepts tangible and engaging. -->
    <!-- Visualization & Content Choices: 
        - Intro: Goal: Inform. Method: Simple text and a static HTML/CSS diagram to introduce schemas. Justification: Sets the stage clearly.
        - Methodology: Goal: Organize/Explain. Method: Two-part interactive HTML/CSS/JS animation. Part 1 shows data points being clustered (ConSpec). Part 2 shows nodes connecting into a graph (GFlowNet). Justification: Animating the algorithms makes these complex processes understandable without needing to read dense text.
        - Planning Simulation: Goal: Demonstrate. Method: HTML/CSS grid with JS animation to show an agent following a schema. Justification: Provides a concrete example of the schema's utility.
        - Comparison: Goal: Compare. Method: Interactive cards (HTML/JS) for qualitative data and a Chart.js bar chart for quantitative "Abstraction Level". Justification: Allows for quick visual comparison and deep dives into details, superior to a static table.
        - Future Work: Goal: Inform. Method: Simple card layout. Justification: Clean and easy to read.
        -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        .data-point {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transition: all 1.5s ease-in-out;
        }
        .schema-node {
            position: absolute;
            transition: all 1s ease-in-out;
            transform: translate(-50%, -50%);
        }
        .schema-edge {
            position: absolute;
            stroke: #475569; /* slate-600 */
            stroke-width: 2;
            transition: stroke-dashoffset 2s ease-in-out;
        }
    </style>
</head>
<body class="bg-stone-50 text-slate-800">

    <header class="bg-white/80 backdrop-blur-lg sticky top-0 z-50 border-b border-stone-200">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <h1 class="text-xl font-bold text-slate-900">Schemas in RL</h1>
            <div class="hidden md:flex space-x-6 text-slate-600">
                <a href="#problem" class="hover:text-teal-600 transition-colors">The Problem</a>
                <a href="#method" class="hover:text-teal-600 transition-colors">How It Works</a>
                <a href="#planning" class="hover:text-teal-600 transition-colors">In Action</a>
                <a href="#comparison" class="hover:text-teal-600 transition-colors">Comparison</a>
                <a href="#future" class="hover:text-teal-600 transition-colors">Future Work</a>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-6 py-12 space-y-24">

        <section id="problem" class="text-center">
            <h2 class="text-4xl font-bold text-slate-900 mb-4">Why Can't AI Generalize Like Humans?</h2>
            <p class="max-w-3xl mx-auto text-lg text-slate-600 mb-8">
                Reinforcement Learning (RL) agents excel at specific tasks but struggle to adapt to new situations. They lack the human ability to use past knowledge to solve novel problems. This research explores how cognitive structures called "schemas"â€”mental blueprints for tasksâ€”can be learned by RL agents to make them more adaptable and efficient.
            </p>
            <div class="bg-white p-8 rounded-xl shadow-sm border border-stone-200 max-w-2xl mx-auto">
                <h3 class="text-xl font-semibold mb-4 text-slate-800">What is a Schema?</h3>
                <p class="text-slate-600 mb-6">A schema breaks a complex goal into a sequence of manageable sub-goals. It's a high-level plan that an agent can follow.</p>
                <div class="flex items-center justify-center space-x-4 text-sm font-medium text-slate-700">
                    <span class="bg-teal-100 text-teal-800 px-4 py-2 rounded-full">Start</span>
                    <span class="text-slate-400">â†’</span>
                    <span class="bg-slate-100 px-4 py-2 rounded-full">Sub-Goal 1</span>
                    <span class="text-slate-400">â†’</span>
                    <span class="bg-slate-100 px-4 py-2 rounded-full">Sub-Goal 2</span>
                    <span class="text-slate-400">â†’</span>
                    <span class="bg-teal-100 text-teal-800 px-4 py-2 rounded-full">Goal</span>
                </div>
            </div>
        </section>

        <section id="method" class="space-y-16">
            <div class="text-center">
                <h2 class="text-4xl font-bold text-slate-900 mb-4">How an Agent Learns a Schema</h2>
                <p class="max-w-3xl mx-auto text-lg text-slate-600">The process involves two main phases: first, identifying the key components of a task, and second, learning how they are related. This section provides an interactive walkthrough of the core algorithms.</p>
            </div>
            
            <div class="grid md:grid-cols-2 gap-12 items-center">
                <div class="bg-white p-8 rounded-xl shadow-sm border border-stone-200">
                    <h3 class="text-2xl font-semibold mb-3 text-slate-800">Phase 1: Finding Critical Features</h3>
                    <p class="text-slate-600 mb-6">The agent first explores its environment to gather data. Using an algorithm called **Contrastive Retrospection (ConSpec)**, it learns to distinguish important states (like "holding the key") from irrelevant ones. This process identifies the core nodes of our schema graph.</p>
                    <button id="runConSpec" class="bg-teal-500 text-white font-semibold px-6 py-3 rounded-lg hover:bg-teal-600 transition-all shadow-sm">
                        â–¶ Run Feature Discovery
                    </button>
                </div>
                <div id="conspec-viz" class="relative bg-slate-100 rounded-lg h-80 w-full border border-stone-200">
                </div>
            </div>

            <div class="grid md:grid-cols-2 gap-12 items-center">
                 <div id="gflownet-viz" class="relative bg-slate-100 rounded-lg h-80 w-full border border-stone-200 order-last md:order-first">
                    <svg id="gflownet-edges" class="absolute top-0 left-0 w-full h-full"></svg>
                    <div id="gflownet-nodes"></div>
                </div>
                <div class="bg-white p-8 rounded-xl shadow-sm border border-stone-200">
                    <h3 class="text-2xl font-semibold mb-3 text-slate-800">Phase 2: Learning Relationships</h3>
                    <p class="text-slate-600 mb-6">With the critical features identified, the agent uses a **Generative Flow Network (GFlowNet)** to learn the temporal and causal links between them. It constructs a probabilistic graph representing the most likely sequences of events, forming the final schema.</p>
                     <button id="runGFlowNet" class="bg-teal-500 text-white font-semibold px-6 py-3 rounded-lg hover:bg-teal-600 transition-all shadow-sm" disabled>
                        â–¶ Build Schema Graph
                    </button>
                </div>
            </div>
        </section>

        <section id="planning" class="space-y-8">
            <div class="text-center">
                <h2 class="text-4xl font-bold text-slate-900 mb-4">Schemas in Action: Hierarchical Planning</h2>
                <p class="max-w-3xl mx-auto text-lg text-slate-600 mb-8">Once the schema is learned, the agent can use it to plan efficiently. Instead of thinking step-by-step, it thinks sub-goal to sub-goal. Watch the simulation below to see how an agent uses its schema to navigate a simple task.</p>
            </div>
            <div class="flex flex-col lg:flex-row gap-8 items-start justify-center">
                <div class="w-full lg:w-auto">
                    <div id="planning-grid" class="grid grid-cols-5 gap-1 bg-slate-200 p-2 rounded-lg shadow-inner w-full max-w-sm mx-auto">
                    </div>
                    <button id="run-planning" class="mt-4 bg-teal-500 text-white font-semibold px-6 py-3 rounded-lg hover:bg-teal-600 transition-all shadow-sm block mx-auto">
                        â–¶ Run Planning Simulation
                    </button>
                </div>
                <div id="planning-schema" class="bg-white p-6 rounded-xl shadow-sm border border-stone-200 w-full lg:max-w-xs flex-shrink-0">
                     <h3 class="text-lg font-semibold mb-4 text-slate-800">Learned Schema Guide</h3>
                     <div class="space-y-3">
                        <div id="schema-node-start" class="flex items-center space-x-3 p-3 bg-slate-100 rounded-lg transition-all">
                            <span class="w-3 h-3 bg-teal-500 rounded-full"></span>
                            <span class="font-medium text-slate-700">Start Position</span>
                        </div>
                        <div class="pl-5 text-slate-400">â†“</div>
                        <div id="schema-node-key" class="flex items-center space-x-3 p-3 bg-slate-100 rounded-lg transition-all">
                            <span class="w-3 h-3 bg-slate-400 rounded-full"></span>
                            <span class="font-medium text-slate-700">Get Key</span>
                        </div>
                         <div class="pl-5 text-slate-400">â†“</div>
                        <div id="schema-node-door" class="flex items-center space-x-3 p-3 bg-slate-100 rounded-lg transition-all">
                           <span class="w-3 h-3 bg-slate-400 rounded-full"></span>
                            <span class="font-medium text-slate-700">Unlock Door</span>
                        </div>
                         <div class="pl-5 text-slate-400">â†“</div>
                        <div id="schema-node-goal" class="flex items-center space-x-3 p-3 bg-slate-100 rounded-lg transition-all">
                           <span class="w-3 h-3 bg-slate-400 rounded-full"></span>
                           <span class="font-medium text-slate-700">Reach Goal</span>
                        </div>
                     </div>
                </div>
            </div>
        </section>

        <section id="comparison" class="space-y-8">
             <div class="text-center">
                <h2 class="text-4xl font-bold text-slate-900 mb-4">How Do Schemas Compare?</h2>
                <p class="max-w-3xl mx-auto text-lg text-slate-600 mb-8">Schemas are a powerful form of abstraction, but they aren't the only one. This section compares schemas to other common methods in RL. Click on each method to see its details and view the chart for a visual comparison of their abstraction levels.</p>
            </div>
            <div id="comparison-container" class="grid md:grid-cols-2 lg:grid-cols-4 gap-4">
            </div>
            <div class="bg-white p-8 rounded-xl shadow-sm border border-stone-200">
                 <h3 class="text-xl font-semibold mb-4 text-slate-800 text-center">Comparison of Abstraction Levels</h3>
                <div class="chart-container">
                    <canvas id="comparisonChart"></canvas>
                </div>
            </div>
        </section>
        
        <section id="future" class="space-y-8">
             <div class="text-center">
                <h2 class="text-4xl font-bold text-slate-900 mb-4">Challenges and the Road Ahead</h2>
                <p class="max-w-3xl mx-auto text-lg text-slate-600">While promising, schema-based learning has open questions and exciting avenues for future research that could lead to more general and human-like AI.</p>
            </div>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-8 rounded-xl shadow-sm border border-stone-200">
                    <h3 class="text-2xl font-semibold mb-4 text-slate-800">Open Challenges</h3>
                    <ul class="space-y-3 text-slate-600 list-disc list-inside">
                        <li><b>Balancing Flexibility and Specificity:</b> Finding the right level of detail for schemas is crucial. Too abstract, and they're useless; too specific, and they don't generalize.</li>
                        <li><b>Scalability and Computation:</b> Discovering and maintaining schemas can be computationally expensive, especially in very large and complex environments.</li>
                    </ul>
                </div>
                 <div class="bg-white p-8 rounded-xl shadow-sm border border-stone-200">
                    <h3 class="text-2xl font-semibold mb-4 text-slate-800">Future Research Directions</h3>
                    <ul class="space-y-3 text-slate-600 list-disc list-inside">
                        <li><b>Adaptive Schema Complexity:</b> Developing schemas that can dynamically adjust their complexity based on the task at hand.</li>
                        <li><b>Hybrid Representations:</b> Combining neural networks for perception with symbolic graphs for reasoning to get the best of both worlds.</li>
                        <li><b>Integration with HRL:</b> Merging schema learning with existing Hierarchical RL frameworks to create even more powerful agents.</li>
                    </ul>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-slate-800 text-slate-400 mt-24">
        <div class="container mx-auto px-6 py-8 text-center">
            <p>This interactive summary is based on the paper "The Role of Schemas in Reinforcement Learning: Insights and Implications for Generalization" by Mandana Samiei, Doina Precup, and Blake A. Richards.</p>
            <p class="text-sm mt-2">All content is derived from the source publication. This visualization was created for educational purposes.</p>
        </div>
    </footer>

<script>
document.addEventListener('DOMContentLoaded', function () {
    
    const comparisonData = [
        { name: 'Schemas', level: 4, purpose: 'Generalization via causal/relational structure, hierarchical planning, knowledge reuse.', strength: 'Holistic abstraction, adaptive planning, rich generalization.' },
        { name: 'Options', level: 2, purpose: 'Temporal abstraction, high-level control, planning over longer horizons.', strength: 'Chunks of behavior, simplifies decision-making.' },
        { name: 'Partial Models', level: 1, purpose: 'Efficient learning with incomplete environment knowledge.', strength: 'Learning in unknown environments.' },
        { name: 'Successor Features', level: 3, purpose: 'Transfer learning when reward changes, predictive state representation.', strength: 'Efficient transfer across reward functions.' },
    ];

    const comparisonContainer = document.getElementById('comparison-container');
    comparisonData.forEach((item, index) => {
        const card = document.createElement('div');
        card.className = 'comparison-card p-6 rounded-lg border-2 cursor-pointer transition-all';
        card.style.borderColor = '#d6d3d1'; 
        card.innerHTML = `
            <h4 class="font-bold text-lg text-slate-800 mb-2">${item.name}</h4>
            <div class="details hidden">
                <p class="text-sm text-slate-600 mt-2"><strong>Purpose:</strong> ${item.purpose}</p>
                <p class="text-sm text-slate-600 mt-2"><strong>Key Strength:</strong> ${item.strength}</p>
            </div>
        `;
        comparisonContainer.appendChild(card);
    });

    const cards = document.querySelectorAll('.comparison-card');
    cards.forEach((card, index) => {
        card.addEventListener('click', () => {
            cards.forEach(c => {
                c.style.backgroundColor = 'white';
                c.style.borderColor = '#d6d3d1';
                c.querySelector('.details').classList.add('hidden');
            });
            card.style.backgroundColor = '#f0fdfa'; // teal-50
            card.style.borderColor = '#14b8a6'; // teal-500
            card.querySelector('.details').classList.remove('hidden');
        });
    });
    if(cards.length > 0) cards[0].click();

    const ctx = document.getElementById('comparisonChart').getContext('2d');
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: comparisonData.map(d => d.name),
            datasets: [{
                label: 'Abstraction Level (Higher is More Abstract)',
                data: comparisonData.map(d => d.level),
                backgroundColor: ['#2dd4bf', '#94a3b8', '#cbd5e1', '#64748b'],
                borderColor: ['#14b8a6', '#64748b', '#94a3b8', '#475569'],
                borderWidth: 1
            }]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.x !== null) {
                                label += `Level ${context.parsed.x}`;
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Abstraction Level' },
                    grid: { color: '#e7e5e4' }
                },
                y: {
                    grid: { display: false }
                }
            }
        }
    });

    const runConSpecBtn = document.getElementById('runConSpec');
    const conspecViz = document.getElementById('conspec-viz');
    const runGFlowNetBtn = document.getElementById('runGFlowNet');

    let conspecRun = false;
    runConSpecBtn.addEventListener('click', () => {
        if(conspecRun) return;
        conspecRun = true;
        runConSpecBtn.disabled = true;
        runConSpecBtn.textContent = 'Discovering...';
        conspecViz.innerHTML = '';
        const numPoints = 50;
        const points = [];
        for (let i = 0; i < numPoints; i++) {
            const point = document.createElement('div');
            point.className = 'data-point';
            point.style.backgroundColor = '#94a3b8'; // slate-400
            point.style.left = `${Math.random() * 90 + 5}%`;
            point.style.top = `${Math.random() * 90 + 5}%`;
            conspecViz.appendChild(point);
            points.push(point);
        }

        setTimeout(() => {
            const clusters = [
                { x: 20, y: 25, color: '#f59e0b' }, 
                { x: 75, y: 30, color: '#3b82f6' }, 
                { x: 50, y: 75, color: '#ef4444' }  
            ];
            points.forEach((point, i) => {
                const cluster = clusters[i % clusters.length];
                point.style.left = `${cluster.x + (Math.random() - 0.5) * 20}%`;
                point.style.top = `${cluster.y + (Math.random() - 0.5) * 20}%`;
                point.style.backgroundColor = cluster.color;
            });
            runConSpecBtn.textContent = 'âœ” Features Discovered';
            runGFlowNetBtn.disabled = false;
        }, 500);
    });

    const gflownetViz = document.getElementById('gflownet-viz');
    const gflownetNodesContainer = document.getElementById('gflownet-nodes');
    const gflownetEdgesSVG = document.getElementById('gflownet-edges');
    let gflownetRun = false;

    runGFlowNetBtn.addEventListener('click', () => {
        if(gflownetRun) return;
        gflownetRun = true;
        runGFlowNetBtn.disabled = true;
        runGFlowNetBtn.textContent = 'Building...';

        const nodePositions = [
            { id: 'start', x: '15%', y: '50%', color: '#2dd4bf', label: 'Start' },
            { id: 'key', x: '45%', y: '25%', color: '#f59e0b', label: 'Key' },
            { id: 'door', x: '65%', y: '75%', color: '#3b82f6', label: 'Door' },
            { id: 'goal', x: '90%', y: '50%', color: '#ef4444', label: 'Goal' },
        ];
        
        const edges = [
            { from: 'start', to: 'key' },
            { from: 'key', to: 'door' },
            { from: 'door', to: 'goal' }
        ];

        gflownetNodesContainer.innerHTML = '';
        nodePositions.forEach(pos => {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'schema-node bg-white p-2 rounded-full shadow-lg flex items-center justify-center';
            nodeEl.style.left = pos.x;
            nodeEl.style.top = pos.y;
            nodeEl.innerHTML = `<span class="w-4 h-4 rounded-full" style="background-color:${pos.color};"></span>`;
            gflownetNodesContainer.appendChild(nodeEl);
        });

        setTimeout(() => {
            gflownetEdgesSVG.innerHTML = '';
            edges.forEach(edge => {
                const fromNode = nodePositions.find(n => n.id === edge.from);
                const toNode = nodePositions.find(n => n.id === edge.to);
                
                const fromX = parseFloat(fromNode.x);
                const fromY = parseFloat(fromNode.y);
                const toX = parseFloat(toNode.x);
                const toY = parseFloat(toNode.y);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', `${fromX}%`);
                line.setAttribute('y1', `${fromY}%`);
                line.setAttribute('x2', `${toX}%`);
                line.setAttribute('y2', `${toY}%`);
                line.setAttribute('class', 'schema-edge');
                const length = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                line.style.strokeDasharray = length * 5; 
                line.style.strokeDashoffset = length * 5;
                gflownetEdgesSVG.appendChild(line);

                setTimeout(() => line.style.strokeDashoffset = 0, 100);
            });
            runGFlowNetBtn.textContent = 'âœ” Schema Built';
        }, 500);
    });

    const planningGrid = document.getElementById('planning-grid');
    const gridState = [
        ['A', 'W', 'W', 'W', 'W'],
        ['P', 'W', 'K', 'W', 'D'],
        ['P', 'P', 'P', 'P', 'P'],
        ['P', 'W', 'W', 'W', 'W'],
        ['G', 'W', 'W', 'W', 'W']
    ];
    const cells = [];
    
    function createGrid() {
        planningGrid.innerHTML = '';
        cells.length = 0;
        gridState.flat().forEach((type, i) => {
            const cell = document.createElement('div');
            cell.className = 'w-16 h-16 flex items-center justify-center text-2xl font-bold transition-colors';
            if (type === 'W') cell.classList.add('bg-slate-300');
            else cell.classList.add('bg-slate-100');
            if (type === 'A') cell.textContent = 'ðŸ¤–';
            if (type === 'K') cell.textContent = 'ðŸ”‘';
            if (type === 'D') cell.textContent = 'ðŸšª';
            if (type === 'G') cell.textContent = 'â­';
            planningGrid.appendChild(cell);
            cells.push(cell);
        });
    }
    
    const runPlanningBtn = document.getElementById('run-planning');
    let planningInProgress = false;

    runPlanningBtn.addEventListener('click', async () => {
        if(planningInProgress) return;
        planningInProgress = true;
        runPlanningBtn.disabled = true;
        runPlanningBtn.textContent = 'Running...';
        createGrid();
        
        const schemaNodes = {
            start: document.getElementById('schema-node-start'),
            key: document.getElementById('schema-node-key'),
            door: document.getElementById('schema-node-door'),
            goal: document.getElementById('schema-node-goal')
        };
        
        const resetSchemaStyles = () => {
            Object.values(schemaNodes).forEach(node => {
                node.classList.remove('bg-teal-100');
                node.classList.add('bg-slate-100');
                node.querySelector('span:first-child').classList.remove('bg-teal-500');
                node.querySelector('span:first-child').classList.add('bg-slate-400');
            });
        };

        const highlightSchemaNode = (nodeName) => {
            resetSchemaStyles();
            schemaNodes[nodeName].classList.add('bg-teal-100');
            schemaNodes[nodeName].querySelector('span:first-child').classList.add('bg-teal-500');
        };

        const agentPath = [0, 5, 6, 7, 12, 11, 10, 15, 20];
        let agentPos = 0;
        
        const moveAgent = async (path) => {
            for (const nextPos of path) {
                cells[agentPos].textContent = '';
                agentPos = nextPos;
                cells[agentPos].textContent = 'ðŸ¤–';
                if(agentPos === 6) { highlightSchemaNode('key'); cells[agentPos].textContent = 'ðŸ¤–ðŸ”‘';}
                if(agentPos === 10) { highlightSchemaNode('door'); cells[14].textContent = '';}
                if(agentPos === 20) { highlightSchemaNode('goal');}

                await new Promise(resolve => setTimeout(resolve, 300));
            }
        };
        
        resetSchemaStyles();
        highlightSchemaNode('start');
        await moveAgent(agentPath);
        
        planningInProgress = false;
        runPlanningBtn.disabled = false;
        runPlanningBtn.textContent = 'â–¶ Re-run Simulation';
    });
    
    createGrid();

});
</script>
</body>
</html>